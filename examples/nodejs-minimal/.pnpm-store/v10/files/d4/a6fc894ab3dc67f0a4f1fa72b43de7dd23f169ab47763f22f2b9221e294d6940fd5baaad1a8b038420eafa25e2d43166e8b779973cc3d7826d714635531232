import randomName from "@scaleway/random-name";
import { resolveOneOf, isJSONObject, unmarshalArrayOfObject, unmarshalDate } from "@scaleway/sdk-client";
const unmarshalPoolUpgradePolicy = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'PoolUpgradePolicy' failed as data isn't a dictionary.`
    );
  }
  return {
    maxSurge: data.max_surge,
    maxUnavailable: data.max_unavailable
  };
};
const unmarshalPool = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'Pool' failed as data isn't a dictionary.`
    );
  }
  return {
    autohealing: data.autohealing,
    autoscaling: data.autoscaling,
    clusterId: data.cluster_id,
    containerRuntime: data.container_runtime,
    createdAt: unmarshalDate(data.created_at),
    id: data.id,
    kubeletArgs: data.kubelet_args,
    maxSize: data.max_size,
    minSize: data.min_size,
    name: data.name,
    newImagesEnabled: data.new_images_enabled,
    nodeType: data.node_type,
    placementGroupId: data.placement_group_id,
    publicIpDisabled: data.public_ip_disabled,
    region: data.region,
    rootVolumeSize: data.root_volume_size,
    rootVolumeType: data.root_volume_type,
    securityGroupId: data.security_group_id,
    size: data.size,
    status: data.status,
    tags: data.tags,
    updatedAt: unmarshalDate(data.updated_at),
    upgradePolicy: data.upgrade_policy ? unmarshalPoolUpgradePolicy(data.upgrade_policy) : void 0,
    version: data.version,
    zone: data.zone
  };
};
const unmarshalVersion = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'Version' failed as data isn't a dictionary.`
    );
  }
  return {
    availableAdmissionPlugins: data.available_admission_plugins,
    availableCnis: data.available_cnis,
    availableContainerRuntimes: data.available_container_runtimes,
    availableFeatureGates: data.available_feature_gates,
    availableKubeletArgs: data.available_kubelet_args,
    label: data.label,
    name: data.name,
    region: data.region
  };
};
const unmarshalMaintenanceWindow = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'MaintenanceWindow' failed as data isn't a dictionary.`
    );
  }
  return {
    day: data.day,
    startHour: data.start_hour
  };
};
const unmarshalClusterAutoUpgrade = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'ClusterAutoUpgrade' failed as data isn't a dictionary.`
    );
  }
  return {
    enabled: data.enabled,
    maintenanceWindow: data.maintenance_window ? unmarshalMaintenanceWindow(data.maintenance_window) : void 0
  };
};
const unmarshalClusterAutoscalerConfig = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'ClusterAutoscalerConfig' failed as data isn't a dictionary.`
    );
  }
  return {
    balanceSimilarNodeGroups: data.balance_similar_node_groups,
    estimator: data.estimator,
    expander: data.expander,
    expendablePodsPriorityCutoff: data.expendable_pods_priority_cutoff,
    ignoreDaemonsetsUtilization: data.ignore_daemonsets_utilization,
    maxGracefulTerminationSec: data.max_graceful_termination_sec,
    scaleDownDelayAfterAdd: data.scale_down_delay_after_add,
    scaleDownDisabled: data.scale_down_disabled,
    scaleDownUnneededTime: data.scale_down_unneeded_time,
    scaleDownUtilizationThreshold: data.scale_down_utilization_threshold
  };
};
const unmarshalClusterOpenIDConnectConfig = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'ClusterOpenIDConnectConfig' failed as data isn't a dictionary.`
    );
  }
  return {
    clientId: data.client_id,
    groupsClaim: data.groups_claim,
    groupsPrefix: data.groups_prefix,
    issuerUrl: data.issuer_url,
    requiredClaim: data.required_claim,
    usernameClaim: data.username_claim,
    usernamePrefix: data.username_prefix
  };
};
const unmarshalCluster = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'Cluster' failed as data isn't a dictionary.`
    );
  }
  return {
    aclAvailable: data.acl_available,
    admissionPlugins: data.admission_plugins,
    apiserverCertSans: data.apiserver_cert_sans,
    autoUpgrade: data.auto_upgrade ? unmarshalClusterAutoUpgrade(data.auto_upgrade) : void 0,
    autoscalerConfig: data.autoscaler_config ? unmarshalClusterAutoscalerConfig(data.autoscaler_config) : void 0,
    clusterUrl: data.cluster_url,
    cni: data.cni,
    commitmentEndsAt: unmarshalDate(data.commitment_ends_at),
    createdAt: unmarshalDate(data.created_at),
    description: data.description,
    dnsWildcard: data.dns_wildcard,
    featureGates: data.feature_gates,
    iamNodesGroupId: data.iam_nodes_group_id,
    id: data.id,
    name: data.name,
    newImagesEnabled: data.new_images_enabled,
    openIdConnectConfig: data.open_id_connect_config ? unmarshalClusterOpenIDConnectConfig(data.open_id_connect_config) : void 0,
    organizationId: data.organization_id,
    privateNetworkId: data.private_network_id,
    projectId: data.project_id,
    region: data.region,
    status: data.status,
    tags: data.tags,
    type: data.type,
    updatedAt: unmarshalDate(data.updated_at),
    upgradeAvailable: data.upgrade_available,
    version: data.version
  };
};
const unmarshalNode = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'Node' failed as data isn't a dictionary.`
    );
  }
  return {
    clusterId: data.cluster_id,
    conditions: data.conditions ? data.conditions : void 0,
    createdAt: unmarshalDate(data.created_at),
    errorMessage: data.error_message,
    id: data.id,
    name: data.name,
    poolId: data.pool_id,
    providerId: data.provider_id,
    publicIpV4: data.public_ip_v4,
    publicIpV6: data.public_ip_v6,
    region: data.region,
    status: data.status,
    updatedAt: unmarshalDate(data.updated_at)
  };
};
const unmarshalACLRule = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'ACLRule' failed as data isn't a dictionary.`
    );
  }
  return {
    description: data.description,
    id: data.id,
    ip: data.ip,
    scalewayRanges: data.scaleway_ranges
  };
};
const unmarshalAddClusterACLRulesResponse = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'AddClusterACLRulesResponse' failed as data isn't a dictionary.`
    );
  }
  return {
    rules: unmarshalArrayOfObject(data.rules, unmarshalACLRule)
  };
};
const unmarshalExternalNodeCoreV1Taint = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'ExternalNodeCoreV1Taint' failed as data isn't a dictionary.`
    );
  }
  return {
    effect: data.effect,
    key: data.key,
    value: data.value
  };
};
const unmarshalExternalNode = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'ExternalNode' failed as data isn't a dictionary.`
    );
  }
  return {
    clusterCa: data.cluster_ca,
    clusterUrl: data.cluster_url,
    cniPluginsVersion: data.cni_plugins_version,
    containerdVersion: data.containerd_version,
    externalIp: data.external_ip,
    iamToken: data.iam_token,
    id: data.id,
    kubeToken: data.kube_token,
    kubeletConfig: data.kubelet_config,
    name: data.name,
    nodeLabels: data.node_labels,
    nodeTaints: unmarshalArrayOfObject(
      data.node_taints,
      unmarshalExternalNodeCoreV1Taint
    ),
    poolVersion: data.pool_version,
    runcVersion: data.runc_version
  };
};
const unmarshalExternalNodeAuth = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'ExternalNodeAuth' failed as data isn't a dictionary.`
    );
  }
  return {
    metadataUrl: data.metadata_url,
    nodeSecretKey: data.node_secret_key
  };
};
const unmarshalListClusterACLRulesResponse = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'ListClusterACLRulesResponse' failed as data isn't a dictionary.`
    );
  }
  return {
    rules: unmarshalArrayOfObject(data.rules, unmarshalACLRule),
    totalCount: data.total_count
  };
};
const unmarshalClusterType = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'ClusterType' failed as data isn't a dictionary.`
    );
  }
  return {
    auditLogsSupported: data.audit_logs_supported,
    availability: data.availability,
    commitmentDelay: data.commitment_delay,
    dedicated: data.dedicated,
    maxEtcdSize: data.max_etcd_size,
    maxNodes: data.max_nodes,
    memory: data.memory,
    name: data.name,
    resiliency: data.resiliency,
    sla: data.sla
  };
};
const unmarshalListClusterAvailableTypesResponse = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'ListClusterAvailableTypesResponse' failed as data isn't a dictionary.`
    );
  }
  return {
    clusterTypes: unmarshalArrayOfObject(
      data.cluster_types,
      unmarshalClusterType
    ),
    totalCount: data.total_count
  };
};
const unmarshalListClusterAvailableVersionsResponse = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'ListClusterAvailableVersionsResponse' failed as data isn't a dictionary.`
    );
  }
  return {
    versions: unmarshalArrayOfObject(data.versions, unmarshalVersion)
  };
};
const unmarshalListClusterTypesResponse = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'ListClusterTypesResponse' failed as data isn't a dictionary.`
    );
  }
  return {
    clusterTypes: unmarshalArrayOfObject(
      data.cluster_types,
      unmarshalClusterType
    ),
    totalCount: data.total_count
  };
};
const unmarshalListClustersResponse = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'ListClustersResponse' failed as data isn't a dictionary.`
    );
  }
  return {
    clusters: unmarshalArrayOfObject(data.clusters, unmarshalCluster),
    totalCount: data.total_count
  };
};
const unmarshalListNodesResponse = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'ListNodesResponse' failed as data isn't a dictionary.`
    );
  }
  return {
    nodes: unmarshalArrayOfObject(data.nodes, unmarshalNode),
    totalCount: data.total_count
  };
};
const unmarshalListPoolsResponse = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'ListPoolsResponse' failed as data isn't a dictionary.`
    );
  }
  return {
    pools: unmarshalArrayOfObject(data.pools, unmarshalPool),
    totalCount: data.total_count
  };
};
const unmarshalListVersionsResponse = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'ListVersionsResponse' failed as data isn't a dictionary.`
    );
  }
  return {
    versions: unmarshalArrayOfObject(data.versions, unmarshalVersion)
  };
};
const unmarshalNodeMetadataCoreV1Taint = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'NodeMetadataCoreV1Taint' failed as data isn't a dictionary.`
    );
  }
  return {
    effect: data.effect,
    key: data.key,
    value: data.value
  };
};
const unmarshalNodeMetadata = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'NodeMetadata' failed as data isn't a dictionary.`
    );
  }
  return {
    clusterCa: data.cluster_ca,
    clusterUrl: data.cluster_url,
    credentialProviderConfig: data.credential_provider_config,
    externalIp: data.external_ip,
    hasGpu: data.has_gpu,
    id: data.id,
    kubeletConfig: data.kubelet_config,
    name: data.name,
    nodeLabels: data.node_labels,
    nodeTaints: unmarshalArrayOfObject(
      data.node_taints,
      unmarshalNodeMetadataCoreV1Taint
    ),
    poolVersion: data.pool_version,
    repoUri: data.repo_uri
  };
};
const unmarshalSetClusterACLRulesResponse = (data) => {
  if (!isJSONObject(data)) {
    throw new TypeError(
      `Unmarshalling the type 'SetClusterACLRulesResponse' failed as data isn't a dictionary.`
    );
  }
  return {
    rules: unmarshalArrayOfObject(data.rules, unmarshalACLRule)
  };
};
const marshalACLRuleRequest = (request, defaults) => ({
  description: request.description,
  ...resolveOneOf([
    { param: "ip", value: request.ip },
    { param: "scaleway_ranges", value: request.scalewayRanges }
  ])
});
const marshalAddClusterACLRulesRequest = (request, defaults) => ({
  acls: request.acls !== void 0 ? request.acls.map((elt) => marshalACLRuleRequest(elt)) : void 0
});
const marshalMaintenanceWindow = (request, defaults) => ({
  day: request.day,
  start_hour: request.startHour
});
const marshalCreateClusterRequestPoolConfigUpgradePolicy = (request, defaults) => ({
  max_surge: request.maxSurge,
  max_unavailable: request.maxUnavailable
});
const marshalCreateClusterRequestAutoUpgrade = (request, defaults) => ({
  enable: request.enable,
  maintenance_window: request.maintenanceWindow !== void 0 ? marshalMaintenanceWindow(request.maintenanceWindow) : void 0
});
const marshalCreateClusterRequestAutoscalerConfig = (request, defaults) => ({
  balance_similar_node_groups: request.balanceSimilarNodeGroups,
  estimator: request.estimator,
  expander: request.expander,
  expendable_pods_priority_cutoff: request.expendablePodsPriorityCutoff,
  ignore_daemonsets_utilization: request.ignoreDaemonsetsUtilization,
  max_graceful_termination_sec: request.maxGracefulTerminationSec,
  scale_down_delay_after_add: request.scaleDownDelayAfterAdd,
  scale_down_disabled: request.scaleDownDisabled,
  scale_down_unneeded_time: request.scaleDownUnneededTime,
  scale_down_utilization_threshold: request.scaleDownUtilizationThreshold
});
const marshalCreateClusterRequestOpenIDConnectConfig = (request, defaults) => ({
  client_id: request.clientId,
  groups_claim: request.groupsClaim,
  groups_prefix: request.groupsPrefix,
  issuer_url: request.issuerUrl,
  required_claim: request.requiredClaim,
  username_claim: request.usernameClaim,
  username_prefix: request.usernamePrefix
});
const marshalCreateClusterRequestPoolConfig = (request, defaults) => ({
  autohealing: request.autohealing,
  autoscaling: request.autoscaling,
  container_runtime: request.containerRuntime,
  kubelet_args: request.kubeletArgs,
  max_size: request.maxSize,
  min_size: request.minSize,
  name: request.name,
  node_type: request.nodeType,
  placement_group_id: request.placementGroupId,
  public_ip_disabled: request.publicIpDisabled,
  root_volume_size: request.rootVolumeSize,
  root_volume_type: request.rootVolumeType,
  security_group_id: request.securityGroupId,
  size: request.size,
  tags: request.tags,
  upgrade_policy: request.upgradePolicy !== void 0 ? marshalCreateClusterRequestPoolConfigUpgradePolicy(
    request.upgradePolicy
  ) : void 0,
  zone: request.zone
});
const marshalCreateClusterRequest = (request, defaults) => ({
  admission_plugins: request.admissionPlugins,
  apiserver_cert_sans: request.apiserverCertSans,
  auto_upgrade: request.autoUpgrade !== void 0 ? marshalCreateClusterRequestAutoUpgrade(request.autoUpgrade) : void 0,
  autoscaler_config: request.autoscalerConfig !== void 0 ? marshalCreateClusterRequestAutoscalerConfig(
    request.autoscalerConfig
  ) : void 0,
  cni: request.cni,
  description: request.description,
  feature_gates: request.featureGates,
  name: request.name || randomName("k8s"),
  open_id_connect_config: request.openIdConnectConfig !== void 0 ? marshalCreateClusterRequestOpenIDConnectConfig(
    request.openIdConnectConfig
  ) : void 0,
  pools: request.pools !== void 0 ? request.pools.map(
    (elt) => marshalCreateClusterRequestPoolConfig(elt)
  ) : void 0,
  private_network_id: request.privateNetworkId,
  tags: request.tags,
  type: request.type,
  version: request.version,
  ...resolveOneOf([
    {
      default: defaults.defaultProjectId,
      param: "project_id",
      value: request.projectId
    },
    {
      default: defaults.defaultOrganizationId,
      param: "organization_id",
      value: request.organizationId
    }
  ])
});
const marshalCreatePoolRequestUpgradePolicy = (request, defaults) => ({
  max_surge: request.maxSurge,
  max_unavailable: request.maxUnavailable
});
const marshalCreatePoolRequest = (request, defaults) => ({
  autohealing: request.autohealing,
  autoscaling: request.autoscaling,
  container_runtime: request.containerRuntime,
  kubelet_args: request.kubeletArgs !== void 0 ? request.kubeletArgs : void 0,
  max_size: request.maxSize,
  min_size: request.minSize,
  name: request.name || randomName("pool"),
  node_type: request.nodeType,
  placement_group_id: request.placementGroupId,
  public_ip_disabled: request.publicIpDisabled,
  root_volume_size: request.rootVolumeSize,
  root_volume_type: request.rootVolumeType,
  security_group_id: request.securityGroupId,
  size: request.size,
  tags: request.tags,
  upgrade_policy: request.upgradePolicy !== void 0 ? marshalCreatePoolRequestUpgradePolicy(request.upgradePolicy) : void 0,
  zone: request.zone ?? defaults.defaultZone
});
const marshalMigratePoolsToNewImagesRequest = (request, defaults) => ({
  pool_ids: request.poolIds
});
const marshalSetClusterACLRulesRequest = (request, defaults) => ({
  acls: request.acls !== void 0 ? request.acls.map((elt) => marshalACLRuleRequest(elt)) : void 0
});
const marshalSetClusterTypeRequest = (request, defaults) => ({
  type: request.type
});
const marshalUpdateClusterRequestAutoUpgrade = (request, defaults) => ({
  enable: request.enable,
  maintenance_window: request.maintenanceWindow !== void 0 ? marshalMaintenanceWindow(request.maintenanceWindow) : void 0
});
const marshalUpdateClusterRequestAutoscalerConfig = (request, defaults) => ({
  balance_similar_node_groups: request.balanceSimilarNodeGroups,
  estimator: request.estimator,
  expander: request.expander,
  expendable_pods_priority_cutoff: request.expendablePodsPriorityCutoff,
  ignore_daemonsets_utilization: request.ignoreDaemonsetsUtilization,
  max_graceful_termination_sec: request.maxGracefulTerminationSec,
  scale_down_delay_after_add: request.scaleDownDelayAfterAdd,
  scale_down_disabled: request.scaleDownDisabled,
  scale_down_unneeded_time: request.scaleDownUnneededTime,
  scale_down_utilization_threshold: request.scaleDownUtilizationThreshold
});
const marshalUpdateClusterRequestOpenIDConnectConfig = (request, defaults) => ({
  client_id: request.clientId,
  groups_claim: request.groupsClaim,
  groups_prefix: request.groupsPrefix,
  issuer_url: request.issuerUrl,
  required_claim: request.requiredClaim,
  username_claim: request.usernameClaim,
  username_prefix: request.usernamePrefix
});
const marshalUpdateClusterRequest = (request, defaults) => ({
  admission_plugins: request.admissionPlugins,
  apiserver_cert_sans: request.apiserverCertSans,
  auto_upgrade: request.autoUpgrade !== void 0 ? marshalUpdateClusterRequestAutoUpgrade(request.autoUpgrade) : void 0,
  autoscaler_config: request.autoscalerConfig !== void 0 ? marshalUpdateClusterRequestAutoscalerConfig(
    request.autoscalerConfig
  ) : void 0,
  description: request.description,
  feature_gates: request.featureGates,
  name: request.name,
  open_id_connect_config: request.openIdConnectConfig !== void 0 ? marshalUpdateClusterRequestOpenIDConnectConfig(
    request.openIdConnectConfig
  ) : void 0,
  tags: request.tags
});
const marshalUpdatePoolRequestUpgradePolicy = (request, defaults) => ({
  max_surge: request.maxSurge,
  max_unavailable: request.maxUnavailable
});
const marshalUpdatePoolRequest = (request, defaults) => ({
  autohealing: request.autohealing,
  autoscaling: request.autoscaling,
  kubelet_args: request.kubeletArgs,
  max_size: request.maxSize,
  min_size: request.minSize,
  size: request.size,
  tags: request.tags,
  upgrade_policy: request.upgradePolicy !== void 0 ? marshalUpdatePoolRequestUpgradePolicy(request.upgradePolicy) : void 0
});
const marshalUpgradeClusterRequest = (request, defaults) => ({
  upgrade_pools: request.upgradePools,
  version: request.version
});
const marshalUpgradePoolRequest = (request, defaults) => ({
  version: request.version
});
export {
  marshalAddClusterACLRulesRequest,
  marshalCreateClusterRequest,
  marshalCreatePoolRequest,
  marshalMigratePoolsToNewImagesRequest,
  marshalSetClusterACLRulesRequest,
  marshalSetClusterTypeRequest,
  marshalUpdateClusterRequest,
  marshalUpdatePoolRequest,
  marshalUpgradeClusterRequest,
  marshalUpgradePoolRequest,
  unmarshalAddClusterACLRulesResponse,
  unmarshalCluster,
  unmarshalExternalNode,
  unmarshalExternalNodeAuth,
  unmarshalListClusterACLRulesResponse,
  unmarshalListClusterAvailableTypesResponse,
  unmarshalListClusterAvailableVersionsResponse,
  unmarshalListClusterTypesResponse,
  unmarshalListClustersResponse,
  unmarshalListNodesResponse,
  unmarshalListPoolsResponse,
  unmarshalListVersionsResponse,
  unmarshalNode,
  unmarshalNodeMetadata,
  unmarshalPool,
  unmarshalSetClusterACLRulesResponse,
  unmarshalVersion
};
