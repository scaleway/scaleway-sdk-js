"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const sdkClient = require("@scaleway/sdk-client");
const content_gen = require("./content.gen.cjs");
const marshalling_gen = require("./marshalling.gen.cjs");
const jsonContentHeaders = {
  "Content-Type": "application/json; charset=utf-8"
};
class API extends sdkClient.API {
  /**
   * Locality of this API.
   * type âˆˆ {'zone','region','global','unspecified'}
   */
  static LOCALITY = sdkClient.toApiLocality({
    regions: ["fr-par", "nl-ams", "pl-waw"]
  });
  pageOfListNamespaces = (request = {}) => this.client.fetch(
    {
      method: "GET",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/namespaces`,
      urlParams: sdkClient.urlParams(
        ["name", request.name],
        ["order_by", request.orderBy],
        ["organization_id", request.organizationId],
        ["page", request.page],
        [
          "page_size",
          request.pageSize ?? this.client.settings.defaultPageSize
        ],
        ["project_id", request.projectId]
      )
    },
    marshalling_gen.unmarshalListNamespacesResponse
  );
  /**
   * List all your namespaces. List all existing namespaces in the specified region.
   *
   * @param request - The request {@link ListNamespacesRequest}
   * @returns A Promise of ListNamespacesResponse
   */
  listNamespaces = (request = {}) => sdkClient.enrichForPagination("namespaces", this.pageOfListNamespaces, request);
  /**
   * Get a namespace. Get the namespace associated with the specified ID.
   *
   * @param request - The request {@link GetNamespaceRequest}
   * @returns A Promise of Namespace
   */
  getNamespace = (request) => this.client.fetch(
    {
      method: "GET",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/namespaces/${sdkClient.validatePathParam("namespaceId", request.namespaceId)}`
    },
    marshalling_gen.unmarshalNamespace
  );
  /**
   * Waits for {@link Namespace} to be in a final state.
   *
   * @param request - The request {@link GetNamespaceRequest}
   * @param options - The waiting options
   * @returns A Promise of Namespace
   */
  waitForNamespace = (request, options) => sdkClient.waitForResource(
    options?.stop ?? ((res) => Promise.resolve(
      !content_gen.NAMESPACE_TRANSIENT_STATUSES.includes(res.status)
    )),
    this.getNamespace,
    request,
    options
  );
  /**
   * Create a new namespace. Create a new namespace in a specified Organization or Project.
   *
   * @param request - The request {@link CreateNamespaceRequest}
   * @returns A Promise of Namespace
   */
  createNamespace = (request) => this.client.fetch(
    {
      body: JSON.stringify(
        marshalling_gen.marshalCreateNamespaceRequest(request, this.client.settings)
      ),
      headers: jsonContentHeaders,
      method: "POST",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/namespaces`
    },
    marshalling_gen.unmarshalNamespace
  );
  /**
   * Update an existing namespace. Update the namespace associated with the specified ID.
   *
   * @param request - The request {@link UpdateNamespaceRequest}
   * @returns A Promise of Namespace
   */
  updateNamespace = (request) => this.client.fetch(
    {
      body: JSON.stringify(
        marshalling_gen.marshalUpdateNamespaceRequest(request, this.client.settings)
      ),
      headers: jsonContentHeaders,
      method: "PATCH",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/namespaces/${sdkClient.validatePathParam("namespaceId", request.namespaceId)}`
    },
    marshalling_gen.unmarshalNamespace
  );
  /**
   * Delete an existing namespace. Delete the namespace associated with the specified ID.
   *
   * @param request - The request {@link DeleteNamespaceRequest}
   * @returns A Promise of Namespace
   */
  deleteNamespace = (request) => this.client.fetch(
    {
      method: "DELETE",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/namespaces/${sdkClient.validatePathParam("namespaceId", request.namespaceId)}`
    },
    marshalling_gen.unmarshalNamespace
  );
  pageOfListFunctions = (request) => this.client.fetch(
    {
      method: "GET",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/functions`,
      urlParams: sdkClient.urlParams(
        ["name", request.name],
        ["namespace_id", request.namespaceId],
        ["order_by", request.orderBy],
        ["organization_id", request.organizationId],
        ["page", request.page],
        [
          "page_size",
          request.pageSize ?? this.client.settings.defaultPageSize
        ],
        ["project_id", request.projectId]
      )
    },
    marshalling_gen.unmarshalListFunctionsResponse
  );
  /**
   * List all your functions.
   *
   * @param request - The request {@link ListFunctionsRequest}
   * @returns A Promise of ListFunctionsResponse
   */
  listFunctions = (request) => sdkClient.enrichForPagination("functions", this.pageOfListFunctions, request);
  /**
   * Get a function. Get the function associated with the specified ID.
   *
   * @param request - The request {@link GetFunctionRequest}
   * @returns A Promise of Function
   */
  getFunction = (request) => this.client.fetch(
    {
      method: "GET",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/functions/${sdkClient.validatePathParam("functionId", request.functionId)}`
    },
    marshalling_gen.unmarshalFunction
  );
  /**
   * Waits for {@link Function} to be in a final state.
   *
   * @param request - The request {@link GetFunctionRequest}
   * @param options - The waiting options
   * @returns A Promise of Function
   */
  waitForFunction = (request, options) => sdkClient.waitForResource(
    options?.stop ?? ((res) => Promise.resolve(
      !content_gen.FUNCTION_TRANSIENT_STATUSES.includes(res.status)
    )),
    this.getFunction,
    request,
    options
  );
  /**
   * Create a new function. Create a new function in the specified region for a specified Organization or Project.
   *
   * @param request - The request {@link CreateFunctionRequest}
   * @returns A Promise of Function
   */
  createFunction = (request) => this.client.fetch(
    {
      body: JSON.stringify(
        marshalling_gen.marshalCreateFunctionRequest(request, this.client.settings)
      ),
      headers: jsonContentHeaders,
      method: "POST",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/functions`
    },
    marshalling_gen.unmarshalFunction
  );
  /**
   * Update an existing function. Update the function associated with the specified ID.
   *
   * @param request - The request {@link UpdateFunctionRequest}
   * @returns A Promise of Function
   */
  updateFunction = (request) => this.client.fetch(
    {
      body: JSON.stringify(
        marshalling_gen.marshalUpdateFunctionRequest(request, this.client.settings)
      ),
      headers: jsonContentHeaders,
      method: "PATCH",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/functions/${sdkClient.validatePathParam("functionId", request.functionId)}`
    },
    marshalling_gen.unmarshalFunction
  );
  /**
   * Delete a function. Delete the function associated with the specified ID.
   *
   * @param request - The request {@link DeleteFunctionRequest}
   * @returns A Promise of Function
   */
  deleteFunction = (request) => this.client.fetch(
    {
      method: "DELETE",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/functions/${sdkClient.validatePathParam("functionId", request.functionId)}`
    },
    marshalling_gen.unmarshalFunction
  );
  /**
   * Deploy a function. Deploy a function associated with the specified ID.
   *
   * @param request - The request {@link DeployFunctionRequest}
   * @returns A Promise of Function
   */
  deployFunction = (request) => this.client.fetch(
    {
      body: "{}",
      headers: jsonContentHeaders,
      method: "POST",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/functions/${sdkClient.validatePathParam("functionId", request.functionId)}/deploy`
    },
    marshalling_gen.unmarshalFunction
  );
  /**
   * List function runtimes. List available function runtimes.
   *
   * @param request - The request {@link ListFunctionRuntimesRequest}
   * @returns A Promise of ListFunctionRuntimesResponse
   */
  listFunctionRuntimes = (request = {}) => this.client.fetch(
    {
      method: "GET",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/runtimes`
    },
    marshalling_gen.unmarshalListFunctionRuntimesResponse
  );
  /**
   * Get an upload URL of a function. Get an upload URL of a function associated with the specified ID.
   *
   * @param request - The request {@link GetFunctionUploadURLRequest}
   * @returns A Promise of UploadURL
   */
  getFunctionUploadURL = (request) => this.client.fetch(
    {
      method: "GET",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/functions/${sdkClient.validatePathParam("functionId", request.functionId)}/upload-url`,
      urlParams: sdkClient.urlParams(["content_length", request.contentLength])
    },
    marshalling_gen.unmarshalUploadURL
  );
  /**
   * Get a download URL of a function. Get a download URL for a function associated with the specified ID.
   *
   * @param request - The request {@link GetFunctionDownloadURLRequest}
   * @returns A Promise of DownloadURL
   */
  getFunctionDownloadURL = (request) => this.client.fetch(
    {
      method: "GET",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/functions/${sdkClient.validatePathParam("functionId", request.functionId)}/download-url`
    },
    marshalling_gen.unmarshalDownloadURL
  );
  pageOfListCrons = (request) => this.client.fetch(
    {
      method: "GET",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/crons`,
      urlParams: sdkClient.urlParams(
        ["function_id", request.functionId],
        ["order_by", request.orderBy],
        ["page", request.page],
        [
          "page_size",
          request.pageSize ?? this.client.settings.defaultPageSize
        ]
      )
    },
    marshalling_gen.unmarshalListCronsResponse
  );
  /**
   * List all crons. List all the cronjobs in a specified region.
   *
   * @param request - The request {@link ListCronsRequest}
   * @returns A Promise of ListCronsResponse
   */
  listCrons = (request) => sdkClient.enrichForPagination("crons", this.pageOfListCrons, request);
  /**
   * Get a cron. Get the cron associated with the specified ID.
   *
   * @param request - The request {@link GetCronRequest}
   * @returns A Promise of Cron
   */
  getCron = (request) => this.client.fetch(
    {
      method: "GET",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/crons/${sdkClient.validatePathParam("cronId", request.cronId)}`
    },
    marshalling_gen.unmarshalCron
  );
  /**
   * Waits for {@link Cron} to be in a final state.
   *
   * @param request - The request {@link GetCronRequest}
   * @param options - The waiting options
   * @returns A Promise of Cron
   */
  waitForCron = (request, options) => sdkClient.waitForResource(
    options?.stop ?? ((res) => Promise.resolve(
      !content_gen.CRON_TRANSIENT_STATUSES.includes(res.status)
    )),
    this.getCron,
    request,
    options
  );
  /**
   * Create a new cron. Create a new cronjob for a function with the specified ID.
   *
   * @param request - The request {@link CreateCronRequest}
   * @returns A Promise of Cron
   */
  createCron = (request) => this.client.fetch(
    {
      body: JSON.stringify(
        marshalling_gen.marshalCreateCronRequest(request, this.client.settings)
      ),
      headers: jsonContentHeaders,
      method: "POST",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/crons`
    },
    marshalling_gen.unmarshalCron
  );
  /**
   * Update an existing cron. Update the cron associated with the specified ID.
   *
   * @param request - The request {@link UpdateCronRequest}
   * @returns A Promise of Cron
   */
  updateCron = (request) => this.client.fetch(
    {
      body: JSON.stringify(
        marshalling_gen.marshalUpdateCronRequest(request, this.client.settings)
      ),
      headers: jsonContentHeaders,
      method: "PATCH",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/crons/${sdkClient.validatePathParam("cronId", request.cronId)}`
    },
    marshalling_gen.unmarshalCron
  );
  /**
   * Delete an existing cron. Delete the cron associated with the specified ID.
   *
   * @param request - The request {@link DeleteCronRequest}
   * @returns A Promise of Cron
   */
  deleteCron = (request) => this.client.fetch(
    {
      method: "DELETE",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/crons/${sdkClient.validatePathParam("cronId", request.cronId)}`
    },
    marshalling_gen.unmarshalCron
  );
  pageOfListDomains = (request) => this.client.fetch(
    {
      method: "GET",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/domains`,
      urlParams: sdkClient.urlParams(
        ["function_id", request.functionId],
        ["order_by", request.orderBy],
        ["page", request.page],
        [
          "page_size",
          request.pageSize ?? this.client.settings.defaultPageSize
        ]
      )
    },
    marshalling_gen.unmarshalListDomainsResponse
  );
  /**
   * List all domain name bindings. List all domain name bindings in a specified region.
   *
   * @param request - The request {@link ListDomainsRequest}
   * @returns A Promise of ListDomainsResponse
   */
  listDomains = (request) => sdkClient.enrichForPagination("domains", this.pageOfListDomains, request);
  /**
   * Get a domain name binding. Get a domain name binding for the function with the specified ID.
   *
   * @param request - The request {@link GetDomainRequest}
   * @returns A Promise of Domain
   */
  getDomain = (request) => this.client.fetch(
    {
      method: "GET",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/domains/${sdkClient.validatePathParam("domainId", request.domainId)}`
    },
    marshalling_gen.unmarshalDomain
  );
  /**
   * Waits for {@link Domain} to be in a final state.
   *
   * @param request - The request {@link GetDomainRequest}
   * @param options - The waiting options
   * @returns A Promise of Domain
   */
  waitForDomain = (request, options) => sdkClient.waitForResource(
    options?.stop ?? ((res) => Promise.resolve(
      !content_gen.DOMAIN_TRANSIENT_STATUSES.includes(res.status)
    )),
    this.getDomain,
    request,
    options
  );
  /**
   * Create a domain name binding. Create a domain name binding for the function with the specified ID.
   *
   * @param request - The request {@link CreateDomainRequest}
   * @returns A Promise of Domain
   */
  createDomain = (request) => this.client.fetch(
    {
      body: JSON.stringify(
        marshalling_gen.marshalCreateDomainRequest(request, this.client.settings)
      ),
      headers: jsonContentHeaders,
      method: "POST",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/domains`
    },
    marshalling_gen.unmarshalDomain
  );
  /**
   * Delete a domain name binding. Delete a domain name binding for the function with the specified ID.
   *
   * @param request - The request {@link DeleteDomainRequest}
   * @returns A Promise of Domain
   */
  deleteDomain = (request) => this.client.fetch(
    {
      method: "DELETE",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/domains/${sdkClient.validatePathParam("domainId", request.domainId)}`
    },
    marshalling_gen.unmarshalDomain
  );
  /**
   * Create a new revocable token.
   *
   * @param request - The request {@link CreateTokenRequest}
   * @returns A Promise of Token
   */
  createToken = (request = {}) => this.client.fetch(
    {
      body: JSON.stringify(
        marshalling_gen.marshalCreateTokenRequest(request, this.client.settings)
      ),
      headers: jsonContentHeaders,
      method: "POST",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/tokens`
    },
    marshalling_gen.unmarshalToken
  );
  /**
   * Get a token.
   *
   * @param request - The request {@link GetTokenRequest}
   * @returns A Promise of Token
   */
  getToken = (request) => this.client.fetch(
    {
      method: "GET",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/tokens/${sdkClient.validatePathParam("tokenId", request.tokenId)}`
    },
    marshalling_gen.unmarshalToken
  );
  /**
   * Waits for {@link Token} to be in a final state.
   *
   * @param request - The request {@link GetTokenRequest}
   * @param options - The waiting options
   * @returns A Promise of Token
   */
  waitForToken = (request, options) => sdkClient.waitForResource(
    options?.stop ?? ((res) => Promise.resolve(
      !content_gen.TOKEN_TRANSIENT_STATUSES.includes(res.status)
    )),
    this.getToken,
    request,
    options
  );
  pageOfListTokens = (request = {}) => this.client.fetch(
    {
      method: "GET",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/tokens`,
      urlParams: sdkClient.urlParams(
        ["function_id", request.functionId],
        ["namespace_id", request.namespaceId],
        ["order_by", request.orderBy],
        ["page", request.page],
        [
          "page_size",
          request.pageSize ?? this.client.settings.defaultPageSize
        ]
      )
    },
    marshalling_gen.unmarshalListTokensResponse
  );
  /**
   * List all tokens.
   *
   * @param request - The request {@link ListTokensRequest}
   * @returns A Promise of ListTokensResponse
   */
  listTokens = (request = {}) => sdkClient.enrichForPagination("tokens", this.pageOfListTokens, request);
  /**
   * Delete a token.
   *
   * @param request - The request {@link DeleteTokenRequest}
   * @returns A Promise of Token
   */
  deleteToken = (request) => this.client.fetch(
    {
      method: "DELETE",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/tokens/${sdkClient.validatePathParam("tokenId", request.tokenId)}`
    },
    marshalling_gen.unmarshalToken
  );
  /**
   * Create a trigger. Create a new trigger for a specified function.
   *
   * @param request - The request {@link CreateTriggerRequest}
   * @returns A Promise of Trigger
   */
  createTrigger = (request) => this.client.fetch(
    {
      body: JSON.stringify(
        marshalling_gen.marshalCreateTriggerRequest(request, this.client.settings)
      ),
      headers: jsonContentHeaders,
      method: "POST",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/triggers`
    },
    marshalling_gen.unmarshalTrigger
  );
  /**
   * Get a trigger. Get a trigger with a specified ID.
   *
   * @param request - The request {@link GetTriggerRequest}
   * @returns A Promise of Trigger
   */
  getTrigger = (request) => this.client.fetch(
    {
      method: "GET",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/triggers/${sdkClient.validatePathParam("triggerId", request.triggerId)}`
    },
    marshalling_gen.unmarshalTrigger
  );
  /**
   * Waits for {@link Trigger} to be in a final state.
   *
   * @param request - The request {@link GetTriggerRequest}
   * @param options - The waiting options
   * @returns A Promise of Trigger
   */
  waitForTrigger = (request, options) => sdkClient.waitForResource(
    options?.stop ?? ((res) => Promise.resolve(
      !content_gen.TRIGGER_TRANSIENT_STATUSES.includes(res.status)
    )),
    this.getTrigger,
    request,
    options
  );
  pageOfListTriggers = (request = {}) => this.client.fetch(
    {
      method: "GET",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/triggers`,
      urlParams: sdkClient.urlParams(
        ["order_by", request.orderBy],
        ["page", request.page],
        [
          "page_size",
          request.pageSize ?? this.client.settings.defaultPageSize
        ],
        ...Object.entries(
          sdkClient.resolveOneOf([
            { param: "function_id", value: request.functionId },
            { param: "namespace_id", value: request.namespaceId },
            {
              default: this.client.settings.defaultProjectId,
              param: "project_id",
              value: request.projectId
            }
          ])
        )
      )
    },
    marshalling_gen.unmarshalListTriggersResponse
  );
  /**
   * List all triggers. List all triggers belonging to a specified Organization or Project.
   *
   * @param request - The request {@link ListTriggersRequest}
   * @returns A Promise of ListTriggersResponse
   */
  listTriggers = (request = {}) => sdkClient.enrichForPagination("triggers", this.pageOfListTriggers, request);
  /**
   * Update a trigger. Update a trigger with a specified ID.
   *
   * @param request - The request {@link UpdateTriggerRequest}
   * @returns A Promise of Trigger
   */
  updateTrigger = (request) => this.client.fetch(
    {
      body: JSON.stringify(
        marshalling_gen.marshalUpdateTriggerRequest(request, this.client.settings)
      ),
      headers: jsonContentHeaders,
      method: "PATCH",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/triggers/${sdkClient.validatePathParam("triggerId", request.triggerId)}`
    },
    marshalling_gen.unmarshalTrigger
  );
  /**
   * Delete a trigger. Delete a trigger with a specified ID.
   *
   * @param request - The request {@link DeleteTriggerRequest}
   * @returns A Promise of Trigger
   */
  deleteTrigger = (request) => this.client.fetch(
    {
      method: "DELETE",
      path: `/functions/v1beta1/regions/${sdkClient.validatePathParam("region", request.region ?? this.client.settings.defaultRegion)}/triggers/${sdkClient.validatePathParam("triggerId", request.triggerId)}`
    },
    marshalling_gen.unmarshalTrigger
  );
}
exports.API = API;
