import {
  appendFileSync,
  readdirSync,
  readFileSync,
  statSync,
  writeFileSync,
} from 'node:fs'
import { join } from 'node:path'

const GENERATED_PATH = 'packages_generated'
const OUTPUT_PATH = 'packages/sdk/src/index.gen.ts'

const toPascal = (s: string) =>
  s
    .split(/[_-]/)
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join('')

const toSlug = (s: string) => s.replace(/_/g, '-')

/**
 * Extract real export names from package's index.gen.ts
 * This ensures we use the exact same names as exported by the package
 */
const getExportsFromPackage = (packagePath: string): string[] => {
  const indexPath = join(packagePath, 'src', 'index.gen.ts')
  try {
    const content = readFileSync(indexPath, 'utf8')
    const exportPattern = /export \* as (\w+) from/g
    const exports: string[] = []
    let match: RegExpExecArray | null

    match = exportPattern.exec(content)
    while (match !== null) {
      exports.push(match[1])
      match = exportPattern.exec(content)
    }

    return exports
  } catch (err: unknown) {
    const message = err instanceof Error ? err.message : String(err)
    throw new Error(`Error reading exports from ${indexPath}: ${message}`)
  }
}

const services = readdirSync(GENERATED_PATH).filter(folder => {
  const fullPath = join(GENERATED_PATH, folder)

  return statSync(fullPath).isDirectory()
})

const AUTO_GENERATE_MESSAGE = `/**
 * This file is automatically generated
 * PLEASE DO NOT EDIT HERE
 */\n`

let output = ''
let importsOutput = ''

writeFileSync(OUTPUT_PATH, AUTO_GENERATE_MESSAGE)

for (const service of services) {
  const slug = toSlug(service)
  const pascal = toPascal(service)
  const packagePath = join(GENERATED_PATH, service)

  // Get real exports from the package
  let exportedNames: string[] = []
  try {
    exportedNames = getExportsFromPackage(packagePath)
  } catch (err: unknown) {
    const message = err instanceof Error ? err.message : String(err)
    throw new Error(
      `Error getting exports for package '${service}': ${message}`,
    )
  }

  if (exportedNames.length > 0) {
    const imports: string[] = []
    const versionsImport: string[] = []
    const mappings: string[] = []

    for (const exportName of exportedNames) {
      // Extract version from export name (e.g., K8Sv1 -> v1, S2SVpnv1alpha1 -> v1alpha1)
      // Version must start with lowercase 'v' followed by digits
      const versionMatch = exportName.match(/(v\d+[a-z]*\d*)$/)
      if (versionMatch) {
        const version = versionMatch[1]
        versionsImport.push(exportName)
        mappings.push(`  ${version}: ${exportName},`)
      }
    }
    imports.push(
      `import { ${versionsImport.join(', ')} } from '@scaleway/sdk-${slug}'`,
    )

    importsOutput += `${imports.join('\n')}\n`
    const importedNames = imports
      .map(line => /{ (.*?) }/.exec(line)?.[1])
      .join(', ')

    output +=
      `/**\n` +
      ` * @deprecated Direct version exports are deprecated. Use the '${pascal}' namespace instead (e.g., ${pascal}.v1).\n` +
      ` */\n`
    output += `export { ${importedNames} }\n`
    output += `export const ${pascal} = {\n${mappings.join('\n')}\n}\n\n`
  }
}
appendFileSync(OUTPUT_PATH, importsOutput)
appendFileSync(
  OUTPUT_PATH,
  "export { createClient, createAdvancedClient } from '@scaleway/sdk-client'\n\n",
)
appendFileSync(OUTPUT_PATH, output)
console.log(`âœ… File generated: ${OUTPUT_PATH}`)
