import { ESLintUtils, AST_NODE_TYPES } from '@typescript-eslint/utils';
import { parse } from 'path';

var _require = require('../package.json'),
    version = _require.version;

var REPO_URL = 'https://github.com/emotion-js/emotion';
var createRule = ESLintUtils.RuleCreator(function (name) {
  var ruleName = parse(name).name;
  return REPO_URL + "/blob/@emotion/eslint-plugin@" + version + "/packages/eslint-plugin/docs/rules/" + ruleName + ".md";
});

var messages$4 = {
  incorrectImport: "emotion's exports should be imported directly from emotion rather than from react-emotion"
};
var importFromEmotion = createRule({
  name: __filename,
  meta: {
    docs: {
      description: 'Ensure styled is imported from @emotion/styled',
      recommended: false
    },
    fixable: 'code',
    messages: messages$4,
    schema: [],
    type: 'problem'
  },
  defaultOptions: [],
  create: function create(context) {
    return {
      ImportDeclaration: function ImportDeclaration(node) {
        if (node.source.value === 'react-emotion' && node.specifiers.some(function (x) {
          return x.type !== AST_NODE_TYPES.ImportDefaultSpecifier;
        })) {
          context.report({
            node: node.source,
            messageId: 'incorrectImport',
            fix: function fix(fixer) {
              if (node.specifiers[0].type === AST_NODE_TYPES.ImportNamespaceSpecifier) {
                return null;
              } // default specifiers are always first


              if (node.specifiers[0].type === AST_NODE_TYPES.ImportDefaultSpecifier) {
                return fixer.replaceText(node, "import " + node.specifiers[0].local.name + " from '@emotion/styled';\nimport { " + node.specifiers.filter(function (x) {
                  return x.type === AST_NODE_TYPES.ImportSpecifier;
                }).map(function (x) {
                  return x.local.name === x.imported.name ? x.local.name : x.imported.name + " as " + x.local.name;
                }).join(', ') + " } from 'emotion';");
              }

              return fixer.replaceText(node.source, "'emotion'");
            }
          });
        }
      }
    };
  }
});

var messages$3 = {
  vanillaEmotion: 'Vanilla emotion should not be used'
};
var noVanilla = createRule({
  name: __filename,
  meta: {
    docs: {
      description: 'Ensure vanilla emotion is not used',
      recommended: false
    },
    messages: messages$3,
    schema: [],
    type: 'problem'
  },
  defaultOptions: [],
  create: function create(context) {
    return {
      ImportDeclaration: function ImportDeclaration(node) {
        if (node.source.value === '@emotion/css') {
          context.report({
            node: node.source,
            messageId: 'vanillaEmotion'
          });
        }
      }
    };
  }
});

/**
 * @fileoverview Choose between string or object syntax
 * @author alex-pex
 */

function isStringStyle(node) {
  if (node.tag.type === AST_NODE_TYPES.Identifier && node.tag.name === 'css') {
    return true;
  } // shorthand notation
  // eg: styled.h1` color: red; `


  if (node.tag.type === AST_NODE_TYPES.MemberExpression && node.tag.object.type === AST_NODE_TYPES.Identifier && node.tag.object.name === 'styled') {
    // string syntax used
    return true;
  } // full notation
  // eg: styled('h1')` color: red; `


  if (node.tag.type === AST_NODE_TYPES.CallExpression && node.tag.callee.type === AST_NODE_TYPES.Identifier && node.tag.callee.name === 'styled') {
    // string syntax used
    return true;
  }

  return false;
}

function isObjectStyle(node) {
  if (node.callee.type === AST_NODE_TYPES.Identifier && node.callee.name === 'css') {
    return true;
  } // shorthand notation
  // eg: styled.h1({ color: 'red' })


  if (node.callee.type === AST_NODE_TYPES.MemberExpression && node.callee.object.type === AST_NODE_TYPES.Identifier && node.callee.object.name === 'styled') {
    // object syntax used
    return true;
  } // full notation
  // eg: styled('h1')({ color: 'red' })


  if (node.callee.type === AST_NODE_TYPES.CallExpression && node.callee.callee.type === AST_NODE_TYPES.Identifier && node.callee.callee.name === 'styled') {
    // object syntax used
    return true;
  }

  return false;
} // ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------


var checkExpressionPreferringObject = function checkExpressionPreferringObject(context, node) {
  switch (node.type) {
    case AST_NODE_TYPES.ArrayExpression:
      node.elements.forEach(function (element) {
        return checkExpressionPreferringObject(context, element);
      });
      return;

    case AST_NODE_TYPES.TemplateLiteral:
      context.report({
        node: node,
        messageId: 'preferObjectStyle'
      });
      return;

    case AST_NODE_TYPES.Literal:
      // validating other literal types seems out of scope of this plugin
      if (typeof node.value !== 'string') {
        return;
      }

      context.report({
        node: node,
        messageId: 'preferObjectStyle'
      });
  }
};

var createPreferredObjectVisitor = function createPreferredObjectVisitor(context) {
  return {
    TaggedTemplateExpression: function TaggedTemplateExpression(node) {
      if (isStringStyle(node)) {
        context.report({
          node: node,
          messageId: 'preferObjectStyle'
        });
      }
    },
    CallExpression: function CallExpression(node) {
      if (isObjectStyle(node)) {
        node.arguments.forEach(function (argument) {
          return checkExpressionPreferringObject(context, argument);
        });
      }
    },
    JSXAttribute: function JSXAttribute(node) {
      if (node.name.name !== 'css') {
        return;
      }

      if (!node.value) {
        context.report({
          node: node,
          messageId: 'emptyCssProp'
        });
        return;
      }

      switch (node.value.type) {
        case AST_NODE_TYPES.Literal:
          // validating other literal types seems out of scope of this plugin
          if (typeof node.value.value !== 'string') {
            return;
          }

          context.report({
            node: node.value,
            messageId: 'preferObjectStyle'
          });
          return;

        case AST_NODE_TYPES.JSXExpressionContainer:
          checkExpressionPreferringObject(context, node.value.expression);
      }
    }
  };
};

var checkExpressionPreferringString = function checkExpressionPreferringString(context, node) {
  switch (node.type) {
    case 'ArrayExpression':
      node.elements.forEach(function (element) {
        return checkExpressionPreferringString(context, element);
      });
      return;

    case 'ObjectExpression':
      context.report({
        node: node,
        messageId: 'preferStringStyle'
      });
      return;

    case 'Literal':
      // validating other literal types seems out of scope of this plugin
      if (typeof node.value !== 'string') {
        return;
      }

      context.report({
        node: node,
        messageId: 'preferWrappingWithCSS'
      });
  }
};

var createPreferredStringVisitor = function createPreferredStringVisitor(context) {
  return {
    CallExpression: function CallExpression(node) {
      if (isObjectStyle(node)) {
        node.arguments.forEach(function (argument) {
          return checkExpressionPreferringString(context, argument);
        });
      }
    },
    JSXAttribute: function JSXAttribute(node) {
      if (node.name.name !== 'css') {
        return;
      }

      if (!node.value) {
        context.report({
          node: node,
          messageId: 'emptyCssProp'
        });
        return;
      }

      switch (node.value.type) {
        case AST_NODE_TYPES.Literal:
          // validating other literal types seems out of scope of this plugin
          if (typeof node.value.value !== 'string') {
            return;
          }

          context.report({
            node: node.value,
            messageId: 'preferWrappingWithCSS'
          });
          return;

        case AST_NODE_TYPES.JSXExpressionContainer:
          checkExpressionPreferringString(context, node.value.expression);
      }
    }
  };
};

var syntaxPreference = createRule({
  name: __filename,
  meta: {
    docs: {
      description: 'Choose between styles written as strings or objects',
      recommended: false
    },
    messages: {
      preferStringStyle: 'Styles should be written using strings.',
      preferObjectStyle: 'Styles should be written using objects.',
      preferWrappingWithCSS: "Prefer wrapping your string styles with `css` call.",
      emptyCssProp: "Empty `css` prop is not valid."
    },
    schema: [{
      "enum": ['string', 'object']
    }],
    type: 'problem'
  },
  defaultOptions: [],
  create: function create(context) {
    var preferredSyntax = context.options[0];

    switch (preferredSyntax) {
      case 'object':
        return createPreferredObjectVisitor(context);

      case 'string':
        return createPreferredStringVisitor(context);

      default:
        return {};
    }
  }
});

var messages$2 = {
  incorrectImport: 'styled should be imported from @emotion/styled'
};
var styledImport = createRule({
  name: __filename,
  meta: {
    docs: {
      description: 'Ensure styled is imported from @emotion/styled',
      recommended: false
    },
    fixable: 'code',
    messages: messages$2,
    schema: [],
    type: 'problem'
  },
  defaultOptions: [],
  create: function create(context) {
    return {
      ImportDeclaration: function ImportDeclaration(node) {
        if (node.source.value === 'react-emotion') {
          var newImportPath = '@emotion/styled';
          context.report({
            node: node.source,
            messageId: 'incorrectImport',
            fix: node.specifiers.length === 1 && node.specifiers[0].type === AST_NODE_TYPES.ImportDefaultSpecifier ? function (fixer) {
              return fixer.replaceText(node.source, "'" + newImportPath + "'");
            } : undefined
          });
        }
      }
    };
  }
});

var JSX_ANNOTATION_REGEX = /\*?\s*@jsx\s+([^\s]+)/;
var JSX_IMPORT_SOURCE_REGEX = /\*?\s*@jsxImportSource\s+([^\s]+)/; // TODO: handling this case
// <div css={`color:hotpink;`} />
// to
// <div css={css`color:hotpink;`} /> + import { css }

var messages$1 = {
  cssProp: "The css prop can only be used if jsxImportSource is set to {{ importSource }}",
  cssPropWithPragma: "The css prop can only be used if jsx from @emotion/react is imported and it is set as the jsx pragma",
  templateLiterals: "Template literals should be replaced with tagged template literals using `css` when using the css prop"
};
var jsxImport = createRule({
  name: __filename,
  meta: {
    docs: {
      description: 'Ensure jsx from @emotion/react is imported',
      recommended: false
    },
    fixable: 'code',
    messages: messages$1,
    schema: {
      type: 'array',
      items: {
        oneOf: [{
          type: 'string'
        }, {
          type: 'object',
          properties: {
            runtime: {
              type: 'string'
            },
            importSource: {
              type: 'string'
            }
          },
          required: ['runtime'],
          additionalProperties: false
        }]
      },
      uniqueItems: true,
      minItems: 0
    },
    type: 'problem'
  },
  defaultOptions: [],
  create: function create(context) {
    var jsxRuntimeMode = context.options.find(function (option) {
      return typeof option === 'object' && option.runtime === 'automatic';
    });

    if (jsxRuntimeMode) {
      return {
        JSXAttribute: function JSXAttribute(node) {
          if (node.name.name !== 'css') {
            return;
          }

          var importSource = (jsxRuntimeMode == null ? void 0 : jsxRuntimeMode.importSource) || '@emotion/react';
          var jsxImportSourcePragmaComment = null;
          var jsxImportSourceMatch;
          var validJsxImportSource = false;
          var sourceCode = context.getSourceCode();
          var pragma = sourceCode.getAllComments().find(function (comment) {
            if (JSX_IMPORT_SOURCE_REGEX.test(comment.value)) {
              jsxImportSourcePragmaComment = comment;
              return true;
            }
          });
          jsxImportSourceMatch = pragma && pragma.value.match(JSX_IMPORT_SOURCE_REGEX);

          if (jsxImportSourceMatch && jsxImportSourceMatch[1] === importSource) {
            validJsxImportSource = true;
          }

          if (!jsxImportSourceMatch) {
            context.report({
              node: node,
              messageId: 'cssProp',
              data: {
                importSource: importSource
              },
              fix: function fix(fixer) {
                return fixer.insertTextBefore(sourceCode.ast.body[0], "/** @jsxImportSource " + importSource + " */\n");
              }
            });
          } else if (!validJsxImportSource && jsxImportSourcePragmaComment) {
            context.report({
              node: node,
              messageId: 'cssProp',
              data: {
                importSource: importSource
              },
              fix: function fix(fixer) {
                /* istanbul ignore if */
                if (jsxImportSourcePragmaComment === null) {
                  throw new Error("Unexpected null when attempting to fix " + context.getFilename() + " - please file a github issue at " + REPO_URL);
                }

                return fixer.replaceText(jsxImportSourcePragmaComment, "/** @jsxImportSource " + importSource + " */");
              }
            });
          }
        }
      };
    }

    return {
      JSXAttribute: function JSXAttribute(node) {
        if (node.name.name !== 'css') {
          return;
        }

        var hasJsxImport = false;
        var emotionCoreNode = null;
        var local = null;
        var sourceCode = context.getSourceCode();
        sourceCode.ast.body.forEach(function (x) {
          if (x.type === AST_NODE_TYPES.ImportDeclaration && (x.source.value === '@emotion/react' || x.source.value === '@emotion/core')) {
            emotionCoreNode = x;

            if (x.specifiers.length === 1 && x.specifiers[0].type === AST_NODE_TYPES.ImportNamespaceSpecifier) {
              hasJsxImport = true;
              local = x.specifiers[0].local.name + '.jsx';
            } else {
              var jsxSpecifier = x.specifiers.find(function (x) {
                return x.type === AST_NODE_TYPES.ImportSpecifier && x.imported.name === 'jsx';
              });

              if (jsxSpecifier) {
                hasJsxImport = true;
                local = jsxSpecifier.local.name;
              }
            }
          }
        });
        var hasSetPragma = false;

        if (context.settings.react && context.settings.react.pragma === 'jsx') {
          hasSetPragma = true;
        }

        var pragma = sourceCode.getAllComments().find(function (node) {
          return JSX_ANNOTATION_REGEX.test(node.value);
        });
        var match = pragma && pragma.value.match(JSX_ANNOTATION_REGEX);

        if (match && (match[1] === local || !local && match[1] === 'jsx')) {
          hasSetPragma = true;
        }

        if (!hasJsxImport || !hasSetPragma) {
          context.report({
            node: node,
            messageId: 'cssPropWithPragma',
            fix: function fix(fixer) {
              if (hasJsxImport) {
                /* istanbul ignore if */
                if (emotionCoreNode === null) {
                  throw new Error("Unexpected null when attempting to fix " + context.getFilename() + " - please file a github issue at " + REPO_URL);
                }

                return fixer.insertTextBefore(emotionCoreNode, "/** @jsx " + local + " */\n");
              }

              if (hasSetPragma) {
                if (emotionCoreNode) {
                  var lastSpecifier = emotionCoreNode.specifiers[emotionCoreNode.specifiers.length - 1];

                  if (lastSpecifier.type === AST_NODE_TYPES.ImportDefaultSpecifier) {
                    return fixer.insertTextAfter(lastSpecifier, ', { jsx }');
                  }

                  return fixer.insertTextAfter(lastSpecifier, ', jsx');
                }

                return fixer.insertTextBefore(sourceCode.ast.body[0], "import { jsx } from '@emotion/react'\n");
              }

              return fixer.insertTextBefore(sourceCode.ast.body[0], "/** @jsx jsx */\nimport { jsx } from '@emotion/react'\n");
            }
          });
          return;
        }
        /* istanbul ignore if */


        if (emotionCoreNode === null) {
          throw new Error("Unexpected null when attempting to fix " + context.getFilename() + " - please file a github issue at " + REPO_URL);
        }

        var _emotionCoreNode = emotionCoreNode,
            specifiers = _emotionCoreNode.specifiers;
        var value = node.value;

        if (value && value.type === AST_NODE_TYPES.JSXExpressionContainer && value.expression.type === AST_NODE_TYPES.TemplateLiteral) {
          var cssSpecifier = specifiers.find(function (x) {
            return x.type === AST_NODE_TYPES.ImportSpecifier && x.imported.name === 'css';
          });
          context.report({
            node: node,
            messageId: 'templateLiterals',
            fix: function fix(fixer) {
              if (cssSpecifier) {
                return fixer.insertTextBefore(value.expression, cssSpecifier.local.name);
              }

              var lastSpecifier = specifiers[specifiers.length - 1];

              if (context.getScope().variables.some(function (x) {
                return x.name === 'css';
              })) {
                return [fixer.insertTextAfter(lastSpecifier, ", css as _css"), fixer.insertTextBefore(value.expression, '_css')];
              }

              return [fixer.insertTextAfter(lastSpecifier, ", css"), fixer.insertTextBefore(value.expression, 'css')];
            }
          });
        }
      }
    };
  }
});

var simpleMappings = new Map([['@emotion/core', '@emotion/react'], ['emotion', '@emotion/css'], ['emotion/macro', '@emotion/css/macro'], ['@emotion/styled-base', '@emotion/styled/base'], ['jest-emotion', '@emotion/jest'], ['babel-plugin-emotion', '@emotion/babel-plugin'], ['eslint-plugin-emotion', '@emotion/eslint-plugin'], ['create-emotion-server', '@emotion/server/create-instance'], ['create-emotion', '@emotion/css/create-instance'], ['emotion-server', '@emotion/server']]);
var messages = {
  renamePackage: "{{ beforeName }} has been renamed to {{ afterName }}, please import it from {{ afterName }} instead",
  exportChange: "The default export of \"{{ name }}\" in Emotion 10 has been moved to a named export, `css`, from \"{{ replacement }}\" in Emotion 11, please import it from \"{{ replacement }}\"",
  emotionTheming: "\"emotion-theming\" has been moved into \"@emotion/react\", please import its exports from \"@emotion/react\""
};
var pkgRenaming = createRule({
  name: __filename,
  meta: {
    docs: {
      description: 'Internal rule',
      recommended: false
    },
    fixable: 'code',
    messages: messages,
    schema: [],
    type: 'problem'
  },
  defaultOptions: [],
  create: function create(context) {
    return {
      ImportDeclaration: function ImportDeclaration(node) {
        var maybeMapping = simpleMappings.get(node.source.value);

        if (maybeMapping !== undefined) {
          context.report({
            node: node.source,
            messageId: 'renamePackage',
            data: {
              beforeName: JSON.stringify(node.source.value),
              afterName: JSON.stringify(maybeMapping)
            },
            fix: function fix(fixer) {
              return fixer.replaceText(node.source, "'" + maybeMapping + "'");
            }
          });
        }

        if ((node.source.value === '@emotion/css' || node.source.value === '@emotion/css/macro') && node.specifiers.length === 1 && node.specifiers[0].type === AST_NODE_TYPES.ImportDefaultSpecifier) {
          var replacement = node.source.value === '@emotion/css' ? '@emotion/react' : '@emotion/react/macro';
          context.report({
            node: node.source,
            messageId: 'exportChange',
            data: {
              name: node.source.value,
              replacement: replacement
            },
            fix: function fix(fixer) {
              return fixer.replaceText(node, "import { css" + (node.specifiers[0].local.name === 'css' ? '' : " as " + node.specifiers[0].local.name) + " } from '" + replacement + "'");
            }
          });
        }

        if (node.source.value === 'emotion-theming') {
          context.report({
            node: node.source,
            messageId: 'emotionTheming',
            fix: function fix(fixer) {
              return fixer.replaceText(node.source, "'@emotion/react'");
            }
          });
        }
      }
    };
  }
});

var rules = {
  'import-from-emotion': importFromEmotion,
  'no-vanilla': noVanilla,
  'syntax-preference': syntaxPreference,
  'styled-import': styledImport,
  'jsx-import': jsxImport,
  'pkg-renaming': pkgRenaming
};

export { rules };
